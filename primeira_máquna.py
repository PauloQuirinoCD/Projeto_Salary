# -*- coding: utf-8 -*-
"""Primeira máquna.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1alswdoSfFxe69YXTlBKxuebPeVPvpYNL

Criar uma máquina preditiva, para prever uma faxa salarial
baseada em um conjunto de dados com as seguintes variáveis
idade, sexo, grau de educação, cargo, experiência e salário.
"""

# baixando as bibliotecas que serão usadas
import pandas as pd
import numpy as np
# Baixando os pacotes de Machine Learning
from sklearn import tree # <= esse ja ia testar 
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# carregando o conjunto de dados
df = pd.read_csv('prever_salario.csv', sep=',')

# verificando as primeiras linhas do conjunto de dados
df.head()

# informações do conjunto de dados, Dtype das variáveis, se ha valores ausentes 
df.info()

df.shape

# existem 6 colunas neste conjunto de dados, com 3 colunas do tipo object
# gender =  gênero, podemos normalizar essa variável como masculino = 1 e feminino = 0
# Education Level = nível de escolaridade também podemos normalizar 
# Job Title = Título do trabalho esta coluna não vai interferir no resultado, 
# ela por si só já e autoinformativa sobre uma media de valores de salário

# NÃO DEVEMOS EXCLUIR ESSES DADOS, DEVEMOS MOSTRAR HABILIDADES DE TRATAMENTO DE DADOS
# Job Title = Título do trabalho,  esta coluna não vai interferir no resultado, podemos exclui-la
df = df.drop(columns = ['Job Title'])
df

# PODE SER AUTOMATIZADO, JUNTO COM A COLUNA EDUCATION LEVEL (COLUNAS CATEGÓRICAS)
# normalizando a coluna ' Gender' = 'Gênero' onde tiver o valor Male(masculino) se tornará = 1 e Feminino = 0.
df['Gender'] = df['Gender'].replace({'Male': 1, 'Female': 0})
df

# EXCLUIR ESSA COLUNA FOI UM ERRO, PORQUE PODE COMPROMETER O DESEMPENHO DA MÁQUINA, REDUINDO INFORMAÇÕES.
# como a coluna 'Education Level' não sabemos quantos níveis estão neste dataset, verifica-se quantos valores únicos tem neste atributo
df['Education Level'].unique()

# ISSO FICA LÁ EM CIMA JUNTO COM O TRATAMENTO DA COLUNA GERDER
# sabemos que tem 3 valores distintos que determina os níveis, agora valomos normalizar esses valores
# Bachelor's = 0, Master's = 1, PhD = 2
df['Education Level'] = df['Education Level'].replace({"Bachelor's": 0, "Master's" : 1, 'PhD' : 2 })
df

# verificar valores NaN em todas as colunas
df.isna().sum()

# em todas as colunas tem dois registros com valores ausentes, 
# antes de tomar uma decisão de substituir ou excluir os valores NaN, vou verificar os dados estátisticos do conjunto de dados
df.describe()

# no geral os valores médios  e centrais estão bem próximos, tornando o conjunto de dados bem balanceados 
# com isso posso substituir os valores NaN, por uma média dos valores de cada coluna.
# substituir valores NaN pela média de cada coluna
df = df.fillna(df.mean())
df.isna().sum()

# Tranto a coluna de saída, o Target. que neste conjunto de dados é a coluna 'Salary'
df['Salary'].unique()

# A coluna 'Salary' tem muitos valores únicos, será preciso fazer uma discretização, neste caso, vou analisar os valores da coluna 
# para entender como será feita a discretização. 
df['Salary'].mean() # Média

df['Salary'].median() # Mediana

df['Salary'].std() # Desvio Padrão

df['Salary'].min() # valor min

# como esse valor mínino está mais baixo que os outros vou verificar ele em expecífico
print(df.loc[df['Salary'] == 350])

df['Salary'].max() # valor Máximo

unique_salaries = sorted(df['Salary'].unique())
unique_salaries

# a diferença entre o menor valor de  registro e o segundo e de 10x o valor praticamente, vou excluir esse registro de valor muito pequeno 
# para deixar a coluna balenceada e que possa ser feita a discretização de forma adequada 
# excluir a linha em que o Salary é igual a 350 no dataframe original
df.drop(df[df['Salary'] == 350].index, inplace=True)
df['Salary'].min()

# agora posso fazer uma discretização a coluna 'Salary' em pelo menos 3 grupos
# discretizar a coluna em 3 bins
df['Salary'] = pd.cut(df['Salary'], bins=3, labels=False)
df

from sklearn.preprocessing import StandardScaler, MinMaxScaler

df

df.describe()

x = df.drop(columns=['Salary'])
y = df.Salary

from sklearn.neighbors import KNeighborsClassifier

X_train, X_test, Y_train, Y_test = train_test_split(x, y, test_size=0.20, random_state = 0)
maquiKNN = KNeighborsClassifier(n_neighbors=5)
maquiKNN.fit(X_train, Y_train)
valor_Previsto = maquiKNN.predict(X_test)
print(((accuracy_score(Y_test, valor_Previsto)))*100)









# Só pra confirmar os grupos 0, 1, 2 na coluna 'Salary'
unique_salaries = sorted(df['Salary'].unique())
unique_salaries

# Verificando a distribuição dos valores distintos na coluna 'Salary'
df['Salary'].value_counts() # com 4 (rótulos) os dados ficam desbalançeados

import matplotlib.pyplot as plt
df['Salary'].value_counts().plot(kind='pie');

"""# Criando as Máquinas Preditivas
 
"""

# separando os valores x e y do  meu conjunto de dados
df_dados = df.drop(columns='Salary')
x = df_dados
y = df.Salary

"""K-Nearest Neighbors (K-Vizinhos mais Proximos)"""

from sklearn.neighbors import KNeighborsClassifier

# dividindo os dados de teste e os dados de treino, informando a quantidade que será usada para teste 0.3 = 30%
X_train, X_test, Y_train, Y_test = train_test_split(x, y, test_size=0.20, random_state = 0)

maquiKNN = KNeighborsClassifier(n_neighbors=5)

maquiKNN.fit(X_train, Y_train)

valor_Previsto = maquiKNN.predict(X_test)

print(((accuracy_score(Y_test, valor_Previsto)))*100)





x

y

""" RandomForestClassifier"""

# Criando uma máquina
Maquina_Preditiva = RandomForestClassifier(n_estimators=30, n_jobs=-1, random_state = 0, min_samples_leaf=2)

Maquina_Preditiva.fit(X_train, Y_train)

# um array, o resultado de um teste a maquina treinada, com os valores de entrada que a máquina nunca viu antes
Y_pred = Maquina_Preditiva.predict(X_test)

from sklearn.metrics import classification_report

print(classification_report(Y_test, Y_pred))

# verificar com nível de acerto dessa máquina1, comparando com os valores esperados, que foram separados la no inicio
print(((accuracy_score(Y_test, Y_pred)))*100)

"""# usando o algoritmo 'DecisionTreeClassifier' do pacote 'Tree'

"""

Maquina_Preditiva = tree.DecisionTreeClassifier(criterion='gini', splitter='best', max_depth=5)
Maquina_Preditiva.fit(X_train, Y_train)
resultado_previsto = Maquina_Preditiva.predict(X_test)
print(((accuracy_score(Y_test, Y_pred)))*100)